{"files":{"pxt.json":"{\n    \"name\": \"arcade-tilemap-a-star\",\n    \"version\": \"0.4.0\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"README.md\",\n        \"main.ts\",\n        \"a-star.ts\",\n        \"path-following.ts\",\n        \"docs/a-star.md\",\n        \"docs/follow-path.md\",\n        \"docs/sprite-percent-path-completed.md\",\n        \"docs/sprite-is-following-path.md\",\n        \"docs/on-path-completion.md\"\n    ],\n    \"testFiles\": [\n        \"tilemap.g.jres\",\n        \"tilemap.g.ts\",\n        \"test.ts\"\n    ],\n    \"public\": true,\n    \"targetVersions\": {\n        \"target\": \"1.8.22\",\n        \"targetId\": \"arcade\"\n    },\n    \"supportedTargets\": [\n        \"arcade\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n","README.md":"# arcade-tilemap-a-star ![Build status badge](https://github.com/jwunderl/arcade-tilemap-a-star/workflows/MakeCode/badge.svg)\n\n\n\n## Use this extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open https://arcade.makecode.com/\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for the URL of this repository and import\n\n## Edit this extension\n\nTo edit this repository in MakeCode.\n\n* open https://arcade.makecode.com/\n* click on **Import** then click on **Import URL**\n* paste the repository URL and click import\n\n## Blocks preview\n\nThis image shows the blocks code from the last commit in master.\nThis image may take a few minutes to refresh.\n\n![A rendered view of the blocks](https://github.com/jwunderl/arcade-tilemap-a-star/raw/master/.makecode/blocks.png)\n\n## Supported targets\n\n* for PXT/arcade\n* for PXT/arcade\n(The metadata above is needed for package search.)\n\n","main.ts":"\n","a-star.ts":"//+array+SimpleLocation sim:7.5%, meowbit:10.5% ms comparing with origin\r\nnamespace scene {\r\n    //costs, scaled up by 1000\r\n    const NEIGHBOR_COST = 1000;\r\n    const DIAGONAL_COST = 1414;\r\n    class PrioritizedLocation {\r\n        constructor(\r\n            public loc: SimpleLocation,\r\n            public cost: number,\r\n            public totalCost: number  //cost+heuristic\r\n        ) { }\r\n    }\r\n\r\n    class LocationNode {\r\n        public visited: boolean;\r\n\r\n        constructor(\r\n            public l: SimpleLocation,\r\n            public parent: LocationNode,\r\n            public lastCost: number\r\n        ) {\r\n            this.visited = false;\r\n        }\r\n    }\r\n\r\n    class SimpleLocation {\r\n        constructor(public col: number, public row: number) { }\r\n    }\r\n\r\n    /**\r\n     * Find the shortest path between start and end that does not contain walls and optionally limited to a pathable tile.\r\n     */\r\n    //% block=\"path from $start to $end||on tiles of $onTilesOf\"\r\n    //% start.shadow=mapgettile\r\n    //% end.shadow=mapgettile\r\n    //% onTilesOf.shadow=tileset_tile_picker\r\n    //% onTilesOf.decompileIndirectFixedInstances=true\r\n    //% help=github:arcade-tilemap-a-star/docs/a-star\r\n    //% group=\"Path Following\" weight=10\r\n    export function aStar(start: tiles.Location, end: tiles.Location, onTilesOf: Image = null) {\r\n        const tm = game.currentScene().tileMap;\r\n        if (!tm || !start || !end)\r\n            return undefined;\r\n\r\n        const end1 = new SimpleLocation(end.col, end.row)\r\n        const start1 = new SimpleLocation(start.col, start.row)\r\n        if (!isWalkable(end1, onTilesOf, tm))\r\n            return undefined;\r\n\r\n        return generalAStar(tm, start1, onTilesOf,\r\n            t => tileLocationHeuristic(t, end1),\r\n            l => l.col == end1.col && l.row == end1.row);\r\n    }\r\n\r\n    export function aStarToAnyOfType(start: tiles.Location, tile: Image, onTilesOf: Image) {\r\n        const tm = game.currentScene().tileMap;\r\n        if (!tm || !start)\r\n            return undefined;\r\n        const start1 = new SimpleLocation(start.col, start.row)\r\n        const endIndex = tm.getImageType(tile);\r\n        const potentialEndPoints = tm.getTilesByType(endIndex);\r\n\r\n        if (!potentialEndPoints || potentialEndPoints.length === 0)\r\n            return undefined;\r\n\r\n        return generalAStar(tm, start1, onTilesOf,\r\n            t => 0,\r\n            l => {\r\n                return endIndex === tm.getTileIndex((l as any)._col, (l as any)._row)\r\n            });\r\n    }\r\n\r\n    export function generalAStar(tm: tiles.TileMap, start: SimpleLocation, onTilesOf: Image,\r\n        heuristic: (tile: SimpleLocation) => number,\r\n        isEnd: (tile: SimpleLocation) => boolean): tiles.Location[] {\r\n\r\n        if (!isWalkable(start, onTilesOf, tm)) {\r\n            return undefined;\r\n        }\r\n\r\n        const consideredTiles: Array<PrioritizedLocation> = []\r\n        const encountedLocations: LocationNode[][] = [[]];\r\n\r\n        function updateOrFillLocation(l: SimpleLocation, parent: LocationNode, cost: number) {\r\n            const row = l.row;\r\n            const col = l.col;\r\n\r\n\r\n            const colData = (encountedLocations[col] || (encountedLocations[col] = []));\r\n            const lData = colData[row];\r\n\r\n            if (!lData) {\r\n                colData[row] = new LocationNode(\r\n                    l,\r\n                    parent,\r\n                    cost\r\n                );\r\n            } else if (lData.lastCost > cost) {\r\n                lData.lastCost = cost;\r\n                lData.parent = parent;\r\n            } else {\r\n                return;\r\n            }\r\n\r\n            const newConsideredTile = new PrioritizedLocation(\r\n                l,\r\n                cost,\r\n                cost + heuristic(l)\r\n            )\r\n\r\n\r\n            if (consideredTiles.length == 0) {\r\n                consideredTiles.push(newConsideredTile)\r\n                return\r\n            }\r\n            let i = consideredTiles.length - 1\r\n            for (; i >= 0; i--) {  // seek & insert from end, last N are more possible hit\r\n                if (newConsideredTile.totalCost < consideredTiles[i].totalCost) {\r\n                    consideredTiles.insertAt(i + 1, newConsideredTile)\r\n                    return;\r\n                }\r\n            }\r\n            if (i < 0)\r\n                consideredTiles.insertAt(0, newConsideredTile)\r\n        }\r\n\r\n        updateOrFillLocation(start, null, 0);\r\n\r\n        let end: SimpleLocation = null;\r\n        while (consideredTiles.length !== 0) {\r\n\r\n            const currLocation = consideredTiles.pop();\r\n\r\n            if (isEnd(currLocation.loc)) {\r\n                end = currLocation.loc;\r\n                break;\r\n            }\r\n\r\n            const row = currLocation.loc.row;\r\n            const col = currLocation.loc.col;\r\n\r\n\r\n            const dataForCurrLocation = encountedLocations[col][row];\r\n\r\n            if (dataForCurrLocation && dataForCurrLocation.visited) {\r\n                continue;\r\n            }\r\n            dataForCurrLocation.visited = true;\r\n\r\n            const left = new SimpleLocation(col - 1, row);\r\n            const right = new SimpleLocation(col + 1, row);\r\n            const top = new SimpleLocation(col, row - 1);\r\n            const bottom = new SimpleLocation(col, row + 1);\r\n\r\n            let leftIsWall = false\r\n            let rightIsWall = false\r\n            let topIsWall = false\r\n            let bottomIsWall = false\r\n\r\n            if (onTilesOf) {\r\n                leftIsWall = !isWalkable(left, onTilesOf, tm);\r\n                rightIsWall = !isWalkable(right, onTilesOf, tm);\r\n                topIsWall = !isWalkable(top, onTilesOf, tm);\r\n                bottomIsWall = !isWalkable(bottom, onTilesOf, tm);\r\n            } else {\r\n                leftIsWall = tm.isObstacle(left.col, left.row);\r\n                rightIsWall = tm.isObstacle(right.col, right.row);\r\n                topIsWall = tm.isObstacle(top.col, top.row);\r\n                bottomIsWall = tm.isObstacle(bottom.col, bottom.row);\r\n            }\r\n\r\n\r\n            const neighborCost = currLocation.cost + NEIGHBOR_COST;\r\n            const cornerCost = currLocation.cost + DIAGONAL_COST;\r\n\r\n            if (!leftIsWall) {\r\n                updateOrFillLocation(left, dataForCurrLocation, neighborCost);\r\n                if (!topIsWall) {\r\n                    const topLeft = new SimpleLocation(col - 1, row - 1);\r\n                    if (!tm.isObstacle(topLeft.col, topLeft.row)) updateOrFillLocation(topLeft, dataForCurrLocation, cornerCost);\r\n                }\r\n                if (!bottomIsWall) {\r\n                    const bottomLeft = new SimpleLocation(col - 1, row + 1);\r\n                    if (!tm.isObstacle(bottomLeft.col, bottomLeft.row)) updateOrFillLocation(bottomLeft, dataForCurrLocation, cornerCost);\r\n                }\r\n            }\r\n\r\n            if (!rightIsWall) {\r\n                updateOrFillLocation(right, dataForCurrLocation, neighborCost);\r\n                if (!topIsWall) {\r\n                    const topRight = new SimpleLocation(col + 1, row - 1);\r\n                    if (!tm.isObstacle(topRight.col, topRight.row)) updateOrFillLocation(topRight, dataForCurrLocation, cornerCost);\r\n                }\r\n                if (!bottomIsWall) {\r\n                    const bottomRight = new SimpleLocation(col + 1, row + 1);\r\n                    if (!tm.isObstacle(bottomRight.col, bottomRight.row)) updateOrFillLocation(bottomRight, dataForCurrLocation, cornerCost);\r\n                }\r\n            }\r\n\r\n            if (!topIsWall) updateOrFillLocation(top, dataForCurrLocation, neighborCost);\r\n            if (!bottomIsWall) updateOrFillLocation(bottom, dataForCurrLocation, neighborCost);\r\n        }\r\n\r\n        const endCol = end && encountedLocations[end.col];\r\n        const endDataNode = endCol && endCol[end.row];\r\n\r\n        // no path found\r\n        if (!end || !endDataNode)\r\n            return undefined;\r\n\r\n        let curr = endDataNode;\r\n\r\n        // otherwise trace back path to end\r\n        const output: tiles.Location[] = [];\r\n\r\n        while (curr) {\r\n            output.unshift(new tiles.Location(curr.l.col, curr.l.row, tm));\r\n            curr = curr.parent;\r\n        }\r\n\r\n        return output;\r\n    }\r\n\r\n    function tileLocationHeuristic(tile: SimpleLocation, target: SimpleLocation) {\r\n        const xDist = Math.abs(target.col - tile.col)\r\n        const yDist = Math.abs(target.row - tile.row)\r\n        return Math.max(xDist, yDist) * NEIGHBOR_COST + Math.min(xDist, yDist) *\r\n            (DIAGONAL_COST - NEIGHBOR_COST)\r\n    }\r\n\r\n    function isWalkable(loc: SimpleLocation, onTilesOf: Image, tm: tiles.TileMap): boolean {\r\n        if (tm.isObstacle(loc.col, loc.row)) return false;\r\n        if (!onTilesOf) return true;\r\n        const img = tm.getTileImage(tm.getTileIndex(loc.col, loc.row))\r\n        return img.equals(onTilesOf);\r\n    }\r\n}\r\n","path-following.ts":"namespace scene {\n    const PATH_FOLLOW_KEY = \"A_STAR_PATH_FOLLOW\";\n    const PATH_COMPLETION_KEY = \"A_STAR_PATH_COMPLETION_HANDLER\";\n\n    class PathFollowingSprite {\n        public index: number;\n        public onEndHandler: () => void;\n\n        constructor (\n            public sprite: Sprite,\n            public path: tiles.Location[],\n            public speed: number\n        ) {\n            this.index = 0;\n        }\n    }\n\n    class PathCompletionEvent {\n        constructor(\n            public kind: number,\n            public handler: (sprite: Sprite, location: tiles.Location) => void\n        ) { }\n    }\n\n    function init() {\n        if (!game.currentScene().data[PATH_FOLLOW_KEY]) {\n            game.currentScene().data[PATH_FOLLOW_KEY] = [] as PathFollowingSprite[];\n            game.currentScene().data[PATH_COMPLETION_KEY] = [] as PathCompletionEvent[];\n\n            game.onUpdate(function () {\n                const store = getPathFollowingSprites();\n                const handlers = getPathCompletionEvents();\n\n                for (let i = store.length - 1; i >= 0; i--)\n                    // note we enumerate from the end so we can safely remove and push without changing\n                    // the worklist\n                {\n                    const pfs = store[i]\n                    const { sprite, index, path, speed } = pfs;\n                    const target: tiles.Location = path[index];\n\n                    const { x, y, vx, vy } = sprite;\n\n                    const pastTargetHorizontally = !vx || (vx < 0 && x <= target.x) || (vx > 0 && x >= target.x);\n                    const pastTargetVertically = !vy || (vy < 0 && y <= target.y) || (vy > 0 && y >= target.y);\n\n                    if (pastTargetHorizontally && pastTargetVertically) {\n                        // target next index\n                        pfs.index++;\n                        const newTarget = path[pfs.index];\n                        if (!newTarget) {\n                            sprite.setVelocity(0, 0);\n                            target.place(sprite);\n                            store.removeAt(i);\n                            // explicit endCb overrides kind cb\n                            if (pfs.onEndHandler) {\n                                pfs.onEndHandler();\n                            } else {\n                                handlers.forEach(completionHandler => {\n                                    if (completionHandler.kind === sprite.kind()) {\n                                        completionHandler.handler(sprite, path[pfs.index - 1]);\n                                    }\n                                });\n                            }\n                        } else {\n                            target.place(sprite);\n                            setVelocityTowards(sprite, newTarget, speed);\n                        }\n                    }\n                }\n            });\n        }\n    }\n\n    function setVelocityTowards(sprite: Sprite, target: tiles.Location, speed: number) {\n        const dx = target.x - sprite.x;\n        const dy = target.y - sprite.y;\n        const dist = Math.sqrt(dx*dx + dy*dy) || 1;\n        sprite.vx = (dx / dist) * speed;\n        sprite.vy = (dy / dist) * speed;\n    }\n\n    // TODO: probably should have logic to bail when a tile that wasn't a wall\n    //      is set to be a wall. Or just use velocity, and let enemy run into wall\n\n    /**\n     * Give a sprite a path to follow\n     * @param sprite sprite to give a path to\n     * @param path path to follow\n     * @param speed speed at which to follow path eg: 50\n     */\n    //% block=\"sprite $sprite follow path $path || speed %speed\"\n    //% sprite.shadow=\"variables_get\"\n    //% sprite.defl=\"mySprite\"\n    //% path.shadow=\"variables_get\"\n    //% path.defl=\"locationTiles\"\n    //% help=github:arcade-tilemap-a-star/docs/follow-path\n    //% group=\"Path Following\" weight=9\n    export function followPath(sprite: Sprite, path: tiles.Location[], speed: number = 50) {\n        if (!sprite)\n            return;\n        if (!path || !path.length || !speed) {\n            const pathFollowingSprites = getPathFollowingSprites();\n            if (pathFollowingSprites) {\n                for (let i = pathFollowingSprites.length - 1; i >= 0; i--) {\n                    const pfs = pathFollowingSprites[i];\n                    if (pfs.sprite === sprite) {\n                        sprite.vx = 0;\n                        sprite.vy = 0;\n                        pathFollowingSprites.removeAt(i);\n                    }\n                }\n            }\n            return;\n        }\n\n        const tm = game.currentScene().tileMap;\n        if (!tm)\n            return;\n\n        // are we in a wall?\n        if (tm.isOnWall(sprite)) {\n            // if so, find the closest path tile by distance and teleport there\n            let nearestTile = path[0]\n            let minDistSquared = 999999;\n            for (let p of path) {\n                const distSqrd = (p.x - sprite.x)**2 + (p.y - sprite.y)**2\n                if (distSqrd < minDistSquared) {\n                    nearestTile = p\n                    minDistSquared = distSqrd\n                }\n            }\n            nearestTile.place(sprite);\n            const remainingPath = getRemainingPath(sprite, path);\n            _followPath(sprite, remainingPath, speed);\n            return\n        }\n\n        // if we're on the path already, just follow the subset of the remaining path\n        const remainingPath = getRemainingPath(sprite, path);\n        if (remainingPath) {\n            _followPath(sprite, remainingPath, speed);\n            return;\n        }\n\n        // otherwise, path with a-star (no heuristic and no onTileOf) to the path\n        const currentLocation = locationOfSprite(sprite)\n        const pathToNearest = generalAStar(tm, currentLocation, null, () => 0, tile => {\n            for (let pathTile of path) {\n                if (tile.col === pathTile.col && tile.row === pathTile.row) {\n                    return true;\n                }\n            }\n            return false;\n        });\n\n        _followPath(sprite, pathToNearest, speed, () => {\n            // then follow the remaining of the path\n            const remainingPath = getRemainingPath(sprite, path);\n            _followPath(sprite, remainingPath, speed);\n        })\n    }\n\n    /**\n     * Returns true if the sprite is currently following a path,\n     * and false otherwise\n     * @param sprite sprite to check if following path\n     */\n    //% block=\"sprite $sprite is following a path\"\n    //% sprite.shadow=\"variables_get\"\n    //% sprite.defl=\"mySprite\"\n    //% help=github:arcade-tilemap-a-star/docs/sprite-is-following-path\n    //% group=\"Path Following\" weight=8\n    export function spriteIsFollowingPath(sprite: Sprite): boolean {\n        init();\n        return getPathFollowingSprites().some(pfs => pfs.sprite === sprite);\n    }\n\n    /**\n     * Returns an approximation between 0 and 100 of how much of the\n     * percentage of the path that the given sprite is following has completed.\n     * If the sprite is not currently following a path,\n     * this returns 100 (as the sprite has trivially completed the empty path).\n     */\n    //% block=\"percent sprite $sprite path completion\"\n    //% sprite.shadow=\"variables_get\"\n    //% sprite.defl=\"mySprite\"\n    //% help=github:arcade-tilemap-a-star/docs/sprite-percent-path-completed\n    //% group=\"Path Following\" weight=7\n    export function spritePercentPathCompleted(sprite: Sprite): number {\n        init();\n        const pfs = getPathFollowingSprites().find(pfs => pfs.sprite === sprite);\n        // TODO: is this behavior useful, or should this return 0 or undefined?\n        if (!pfs)\n            return 100;\n        return 100 - (100 * (pfs.path.length - pfs.index) / pfs.path.length);\n    }\n\n    /**\n     * Event handler for when a sprite of the given kind completes a path\n     */\n    //% group=\"Overlaps\"\n    //% weight=100 draggableParameters=\"reporter\"\n    //% block=\"on $sprite of kind $kind completes path at $location\"\n    //% kind.shadow=spritekind\n    //% help=github:arcade-tilemap-a-star/docs/on-path-completion\n    //% group=\"Path Following\" weight=6\n    export function onPathCompletion(\n        kind: number,\n        handler: (sprite: Sprite, location: tiles.Location) => void\n    ) {\n        init();\n        if (kind == null || !handler)\n            return;\n        getPathCompletionEvents().push(\n            new PathCompletionEvent(kind, handler)\n        );\n    }\n\n    export function teleportToAndFollowPath(sprite: Sprite, path: tiles.Location[], speed?: number) {\n        _followPath(sprite, path, speed);\n    }\n\n    export function _followPath(sprite: Sprite, path: tiles.Location[], speed?: number, endCb?: () => void) {\n        if (!sprite)\n            return;\n\n        init();\n        const store = getPathFollowingSprites();\n        const previousEl = store.find(el => el.sprite === sprite);\n\n        const start = path && path[0];\n        if (!start) {\n            if (previousEl) {\n                store.removeElement(previousEl);\n            }\n            return;\n        }\n\n        const pfs = previousEl || new PathFollowingSprite(\n            sprite,\n            path,\n            speed || 50\n        );\n        if (previousEl) {\n            if (speed)\n                previousEl.speed = speed;\n            previousEl.path = path;\n            previousEl.index = 0;\n\n            if (endCb) {\n                previousEl.onEndHandler = endCb;\n            }\n        } else {\n            pfs.onEndHandler = endCb;\n            store.push(pfs);\n        }\n\n        setVelocityTowards(sprite, start, pfs.speed)\n    }\n\n    /**\n     * Returns the index in the path which is closest to the current sprite by direct distance\n     */\n    export function getNearestPathIdx(sprite: Sprite, path: tiles.Location[]): number {\n        let minDistSqrd = 99999\n        let idx = 0;\n        for (let i = 0; i < path.length; i++) {\n            let t = path[i];\n            let distSqrd = (sprite.x - t.x)**2 + (sprite.y - t.y)**2;\n            if (distSqrd < minDistSqrd) {\n                minDistSqrd = distSqrd;\n                idx = i;\n            }\n        }\n        return idx\n    }\n\n    function getPathFollowingSprites(): PathFollowingSprite[] {\n        return game.currentScene().data[PATH_FOLLOW_KEY] as PathFollowingSprite[];\n    }\n\n    function getPathCompletionEvents(): PathCompletionEvent[] {\n        return game.currentScene().data[PATH_COMPLETION_KEY] as PathCompletionEvent[];\n    }\n\n    function screenCoordinateToTile(value: number) {\n        const tm = game.currentScene().tileMap;\n        if (!tm) return value >> 4;\n        return value >> tm.scale;\n    }\n\n    function locationOfSprite(s: Sprite): tiles.Location {\n        return tiles.getTileLocation(screenCoordinateToTile(s.x), screenCoordinateToTile(s.y));\n    }\n\n    function getRemainingPath(sprite: Sprite, path: tiles.Location[]): tiles.Location[] | null {\n        const currentLocation = locationOfSprite(sprite)\n        for (let i = 0; i < path.length; i++) {\n            const pathTile = path[i];\n            if (currentLocation.x === pathTile.x && currentLocation.y === pathTile.y) {\n                const remainingPath = i === 0 ? path : path.filter((_, j) => j >= i);\n                return remainingPath;\n            }\n        }\n        return null\n    }\n}","docs/a-star.md":"# a star\n\nGet an array of tiles that form a path from **start** to **end**\nthat does not contain walls (and optionally is restrict to a given type of tile).\n\n```sig\nscene.aStar(null, null)\n```\n\n## Parameters\n\n* **start**: A tile location to start at\n* **end**: A tile location to end at\n* **onTilesOf** (optional): a type of tile to restrict movement to, for example water or dirt.\n\n## Returns\n\n* an array of tile locations that form a path from **start** to **end**\n\n## Example\n\nCreates a path from the top left corner of the screen to the bottom right corner of the screen (`myPath`).\nPrints out how many tiles are in that path.\n\n```blocks\nlet myPath = scene.aStar(tiles.getTileLocation(0, 0), tiles.getTileLocation(9, 7))\nconsole.log(myPath.length)\n```\n\n```package\narcade-tilemap-a-star=github:jwunderl/arcade-tilemap-a-star\n```","docs/follow-path.md":"# follow Path\n\n```sig\nscene.followPath(null, null)\n```\n\n## Parameters\n\n* **sprite**: The sprite that should follow the path\n* **path**: An array of tile locations a path should follow\n* **speed** (optional): A speed (in pixels per second) at which the sprite should follow the path.\n\n## Example\n\n```blocks\nlet myPath = scene.aStar(tiles.getTileLocation(0, 0), tiles.getTileLocation(9, 7))\nlet mySprite = sprites.create(img`\n    . . . . . . . . . . . . . . . . \n    . . . . . . . . . . . . . . . . \n    . . . . . . . . . b 5 5 b . . . \n    . . . . . . b b b b b b . . . . \n    . . . . . b b 5 5 5 5 5 b . . . \n    . b b b b b 5 5 5 5 5 5 5 b . . \n    . b d 5 b 5 5 5 5 5 5 5 5 b . . \n    . . b 5 5 b 5 d 1 f 5 d 4 f . . \n    . . b d 5 5 b 1 f f 5 4 4 c . . \n    b b d b 5 5 5 d f b 4 4 4 4 b . \n    b d d c d 5 5 b 5 4 4 4 4 4 4 b \n    c d d d c c b 5 5 5 5 5 5 5 b . \n    c b d d d d d 5 5 5 5 5 5 5 b . \n    . c d d d d d d 5 5 5 5 5 d b . \n    . . c b d d d d d 5 5 5 b b . . \n    . . . c c c c c c c c b b . . . \n    `, SpriteKind.Player)\nscene.followPath(mySprite, myPath)\n```\n\n```package\narcade-tilemap-a-star=github:jwunderl/arcade-tilemap-a-star\n```\n","docs/sprite-percent-path-completed.md":"# sprite Percent Path Completed\n\nReturns an approximation between 0 and 100 of how much of the percentage of the path\nthat the given sprite is following has completed.\nIf the sprite is not currently following a path,\nthis returns 100 (as the sprite has trivially completed the empty path).\n\n```sig\nscene.spritePercentPathCompleted(null)\n```\n\n## Parameters\n\n* **sprite**: A sprite to get the path completion percentage of.\n\n## Returns\n\n* A percentage between 0 and 100 based on how much of a path the sprite has completed\n\n## Example\n\nCreates a sprite that will constantly say what percentage of it's current path it has completed.\n\n```blocks\nlet mySprite = sprites.create(img`\n    . . . . . . . . . . . . . . . . \n    . . . . . . . . . . . . . . . . \n    . . . . . . . . . b 5 5 b . . . \n    . . . . . . b b b b b b . . . . \n    . . . . . b b 5 5 5 5 5 b . . . \n    . b b b b b 5 5 5 5 5 5 5 b . . \n    . b d 5 b 5 5 5 5 5 5 5 5 b . . \n    . . b 5 5 b 5 d 1 f 5 d 4 f . . \n    . . b d 5 5 b 1 f f 5 4 4 c . . \n    b b d b 5 5 5 d f b 4 4 4 4 b . \n    b d d c d 5 5 b 5 4 4 4 4 4 4 b \n    c d d d c c b 5 5 5 5 5 5 5 b . \n    c b d d d d d 5 5 5 5 5 5 5 b . \n    . c d d d d d d 5 5 5 5 5 d b . \n    . . c b d d d d d 5 5 5 b b . . \n    . . . c c c c c c c c b b . . . \n    `, SpriteKind.Player)\ngame.onUpdate(() => {\n    mySprite.say(scene.spritePercentPathCompleted(mySprite))\n})\n```\n\n```package\narcade-tilemap-a-star=github:jwunderl/arcade-tilemap-a-star\n```","docs/sprite-is-following-path.md":"# sprite Is Following Path\n\nReturns true if the sprite is currently following a path,\nand false otherwise\n\n```sig\nscene.spriteIsFollowingPath(null)\n```\n\n## Parameters\n\n* **sprite**: A sprite to check if it is currently following a path.\n\n## Returns\n\n* True if the sprite is currently following a path, and false otherwise.\n\n## Example\n\nCreates a sprite that will constantly say if it's true or false that it's following a path.\n\n```blocks\nlet mySprite = sprites.create(img`\n    . . . . . . . . . . . . . . . . \n    . . . . . . . . . . . . . . . . \n    . . . . . . . . . b 5 5 b . . . \n    . . . . . . b b b b b b . . . . \n    . . . . . b b 5 5 5 5 5 b . . . \n    . b b b b b 5 5 5 5 5 5 5 b . . \n    . b d 5 b 5 5 5 5 5 5 5 5 b . . \n    . . b 5 5 b 5 d 1 f 5 d 4 f . . \n    . . b d 5 5 b 1 f f 5 4 4 c . . \n    b b d b 5 5 5 d f b 4 4 4 4 b . \n    b d d c d 5 5 b 5 4 4 4 4 4 4 b \n    c d d d c c b 5 5 5 5 5 5 5 b . \n    c b d d d d d 5 5 5 5 5 5 5 b . \n    . c d d d d d d 5 5 5 5 5 d b . \n    . . c b d d d d d 5 5 5 b b . . \n    . . . c c c c c c c c b b . . . \n    `, SpriteKind.Player)\ngame.onUpdate(() => {\n    mySprite.say(scene.spriteIsFollowingPath(mySprite))\n})\n```\n\n```package\narcade-tilemap-a-star=github:jwunderl/arcade-tilemap-a-star\n```","docs/on-path-completion.md":"# on Path Completion\n\nSet code to run when a sprite of the given kind has finished following it's path.\n\n```sig\nscene.onPathCompletion(null, null)\n```\n\n## Parameters\n\n* **kind**: A kind of sprite to register an event for.\n* **handler**: The code to run when a sprite finishes it's path.\n>* **sprite**: The sprite that has completed it's Path.\n>* **location**: The location at which the sprite has completed it's path.\n\n## Example\n\nCreates an event so  when an enemy finishes it's path, the game end\n\n```blocks\nscene.onPathCompletion(SpriteKind.Enemy, function (sprite, location) {\n\tgame.over(false);\n})\n```\n\nCreates an event so that a food sprite is destroyed and the location becomes a wall\nwhen a path is completed.\n\n```blocks\nscene.onPathCompletion(SpriteKind.Food, function (sprite, location) {\n\tsprite.destroy(effects.trail, 500)\n\ttiles.setWallAt(location, true)\n})\n```\n\n```package\narcade-tilemap-a-star=github:jwunderl/arcade-tilemap-a-star\n```","tilemap.g.jres":"{\n    \"transparency16\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"tilemapTile\": true\n    },\n    \"tile1\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"tilemapTile\": true\n    },\n    \"tile2\": {\n        \"data\": \"hwQQABAAAADbu7u7u7u7vdu7uxu9u7u927u7G7G7u728vbsbsbvby7y9uxuxu9vLvL2727G728u8vbu7u7vby7y9u7u7u9vLvL27u7u728u8vbsbvbvby7y9uxuxu9vLvL27G7G728u8vbsbsbvby7y9u9uxu9vLvL27u7u728u8vbu7u7vbyw==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"tilemapTile\": true,\n        \"displayName\": \"myTile\"\n    },\n    \"tile3\": {\n        \"data\": \"hwQQABAAAAC7y8zMzMzMzN29u7u7u7u7u9vd3d3d3d27u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u9sREbvbERG7GxHRuxsR0bu7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7vb3d3d3d3d3b27u7u7u7u7y8zMzMzMzA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"tilemapTile\": true,\n        \"displayName\": \"myTile0\"\n    },\n    \"tile4\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"tilemapTile\": true,\n        \"displayName\": \"myTile1\"\n    },\n    \"level\": {\n        \"id\": \"level\",\n        \"mimeType\": \"application/mkcd-tilemap\",\n        \"data\": \"MTAxMDAwMTAwMDAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAxMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMTAxMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAxMDIwMjAyMDEwMTAyMDIwMjAyMDIwMjAyMDIwMjAyMDEwMjAyMDIwMjAxMDIwMjAyMDIwMjAyMDIwMjAyMDIwMTAyMDIwMjAyMDEwMjAyMDIwMjAyMDIwMTAxMDEwMTAxMDIwMjAyMDEwMTAyMDIwMjAyMDIwMjAyMDIwMTAyMDIwMjAyMDEwMTAyMDIwMjAyMDIwMjAyMDIwMjAxMDIwMjAyMDEwMTAyMDIwMjAyMDIwMTAxMDEwMTAxMDEwMTAxMDEwMTAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMA==\",\n        \"tileset\": [\n            \"myTiles.transparency16\",\n            \"sprites.castle.tilePath5\",\n            \"sprites.castle.tileGrass1\"\n        ],\n        \"displayName\": \"level\"\n    },\n    \"level1\": {\n        \"id\": \"level1\",\n        \"mimeType\": \"application/mkcd-tilemap\",\n        \"data\": \"MTAwYTAwMDgwMDA4MDcwNzA3MDcwNzA3MDcwNzA3MDQwNzA3MDcwNzA3MDcwNzA3MDcwMTAyMDIwMjAyMDUwNzA3MDcwNzA3MDcwNzA3MDcwNDA3MDcwNzA3MDcwNzA3MDcwNzAxMDIwMjAyMDUwNzA3MDcwNzA3MDcwNzA3MDcwNDA2MDIwMjAyMDIwMjAyMDIwMjAzMDcwNzA3MDcwNzA3MDcwNzA3MDcyMDIyMjIyMjIyMjAyMjIyMjIyMjAwMDAwMDIyMjIyMjIyMDIyMjIyMjIyMjAyMDAwMDIyMjIyMjIyMDIwMDAwMDAwMDAwMjIyMjIyMjIyMg==\",\n        \"tileset\": [\n            \"myTiles.transparency16\",\n            \"sprites.vehicle.roadTurn3\",\n            \"sprites.vehicle.roadHorizontal\",\n            \"sprites.vehicle.roadTurn4\",\n            \"sprites.vehicle.roadVertical\",\n            \"sprites.vehicle.roadTurn2\",\n            \"myTiles.tile2\",\n            \"sprites.castle.tilePath5\",\n            \"myTiles.tile3\"\n        ],\n        \"displayName\": \"level1\"\n    },\n    \"*\": {\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"dataEncoding\": \"base64\",\n        \"namespace\": \"myTiles\"\n    }\n}","tilemap.g.ts":"// Auto-generated code. Do not edit.\nnamespace myTiles {\n    //% fixedInstance jres blockIdentity=images._tile\n    export const transparency16 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._tile\n    export const tile1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._tile\n    export const tile2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._tile\n    export const tile3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._tile\n    export const tile4 = image.ofBuffer(hex``);\n\n    helpers._registerFactory(\"tilemap\", function(name: string) {\n        switch(helpers.stringTrim(name)) {\n            case \"level\":\n            case \"level\":return tiles.createTilemap(hex`1000100002020202020202020202020202020202020202020202020202020202020202020202020201020202020202020202020201010101010101010101010202020202020202020202020202020101020202020202020202020201020202010102020202020202020202010202020201020202020202020202020102020202010202020202020101010101020202010102020202020202020102020202010102020202020202020201020202010102020202020101010101010101010102020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202`, img`\n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n`, [myTiles.transparency16,sprites.castle.tilePath5,sprites.castle.tileGrass1], TileScale.Sixteen);\n            case \"level1\":\n            case \"level1\":return tiles.createTilemap(hex`0a0008000807070707070707070704070707070707070707010202020205070707070707070707040707070707070707070102020205070707070707070707040602020202020202020307070707070707070707`, img`\n. 2 2 2 2 2 2 2 2 2 \n. 2 2 2 2 2 2 2 2 2 \n. . . . . . 2 2 2 2 \n2 2 2 2 2 . 2 2 2 2 \n2 2 2 2 2 . . . . . \n2 2 2 2 2 2 2 2 2 . \n. . . . . . . . . . \n2 2 2 2 2 2 2 2 2 2 \n`, [myTiles.transparency16,sprites.vehicle.roadTurn3,sprites.vehicle.roadHorizontal,sprites.vehicle.roadTurn4,sprites.vehicle.roadVertical,sprites.vehicle.roadTurn2,myTiles.tile2,sprites.castle.tilePath5,myTiles.tile3], TileScale.Sixteen);\n        }\n        return null;\n    })\n\n    helpers._registerFactory(\"tile\", function(name: string) {\n        switch(helpers.stringTrim(name)) {\n            case \"transparency16\":return transparency16;\n            case \"tile1\":return tile1;\n            case \"myTile\":\n            case \"tile2\":return tile2;\n            case \"myTile0\":\n            case \"tile3\":return tile3;\n            case \"myTile1\":\n            case \"tile4\":return tile4;\n        }\n        return null;\n    })\n\n}\n// Auto-generated code. Do not edit.\n","test.ts":"\ncreateIcon()\nfunction createIcon() {\n    scene.setBackgroundColor(13)\n    tiles.setTilemap(tilemap`level1`);\n    const start = tiles.getRandomTileByType(myTiles.tile2);\n    const end = tiles.getRandomTileByType(myTiles.tile3)\n    const path = scene.aStar(start, end)\n\n    game.onUpdateInterval(1500, function() {\n        const car = sprites.create(img`\n            . . . . . . . . . . . . . . . .\n            . . . . 6 6 6 6 6 6 6 6 . . . .\n            . . . 6 9 6 6 6 6 6 6 c 6 . . .\n            . . 6 c 9 6 6 6 6 6 6 c c 6 . .\n            . 6 c c 9 9 9 9 9 9 6 c c 9 6 d\n            . 6 c 6 8 8 8 8 8 8 8 b c 9 6 6\n            . 6 6 8 b b 8 b b b 8 8 b 9 6 6\n            . 6 8 b b b 8 b b b b 8 6 6 6 6\n            . 8 8 6 6 6 8 6 6 6 6 6 8 6 6 6\n            . 8 8 8 8 8 8 f 8 8 8 f 8 6 d d\n            . 8 8 8 8 8 8 f 8 8 f 8 8 8 6 d\n            . 8 8 8 8 8 8 f f f 8 8 8 8 8 8\n            . 8 f f f f 8 8 8 8 f f f 8 8 8\n            . . f f f f f 8 8 f f f f f 8 .\n            . . . f f f . . . . f f f f . .\n            . . . . . . . . . . . . . . . .\n        `, randint(1, 3))\n        tiles.placeOnTile(car, start)\n        scene.followPath(car, path)\n    });\n\n    game.onUpdate(() => {\n        for (const s of sprites.allOfKind(1)) {\n            if (s.vy < 0) {\n                s.setImage(sprites.vehicle.carBlueBack)\n            } else if (s.vx > 0) {\n                s.setImage(sprites.vehicle.carBlueRight)\n            } else if (s.vx < 0) {\n                s.setImage(sprites.vehicle.carBlueLeft)\n            }\n        }\n        for (const s of sprites.allOfKind(2)) {\n            if (s.vy < 0) {\n                s.setImage(sprites.vehicle.carRedBack)\n            } else if (s.vx > 0) {\n                s.setImage(sprites.vehicle.carRedRight)\n            } else if (s.vx < 0) {\n                s.setImage(sprites.vehicle.carRedLeft)\n            }\n        }\n        for (const s of sprites.allOfKind(3)) {\n            if (s.vy < 0) {\n                s.setImage(sprites.vehicle.carPinkBack)\n            } else if (s.vx > 0) {\n                s.setImage(sprites.vehicle.carPinkRight)\n            } else if (s.vx < 0) {\n                s.setImage(sprites.vehicle.carPinkLeft)\n            }\n        }\n    });\n    for (let i = 1; i <= 3; ++i ){\n        scene.onPathCompletion(\n            i,\n            (sprite: Sprite, location: tiles.Location) => sprite.destroy()\n        );\n    }\n}\n\nfunction testPath() {\n    game.consoleOverlay.setVisible(true, 2)\n    tiles.setTilemap(tilemap`level`)\n\n    let mySprite: Sprite = sprites.create(img`\n        . . . . . f f 4 4 f f . . . . .\n        . . . . f 5 4 5 5 4 5 f . . . .\n        . . . f e 4 5 5 5 5 4 e f . . .\n        . . f b 3 e 4 4 4 4 e 3 b f . .\n        . . f 3 3 3 3 3 3 3 3 3 3 f . .\n        . f 3 3 e b 3 e e 3 b e 3 3 f .\n        . f 3 3 f f e e e e f f 3 3 f .\n        . f b b f b f e e f b f b b f .\n        . f b b e 1 f 4 4 f 1 e b b f .\n        f f b b f 4 4 4 4 4 4 f b b f f\n        f b b f f f e e e e f f f b b f\n        . f e e f b d d d d b f e e f .\n        . . e 4 c d d d d d d c 4 e . .\n        . . e f b d b d b d b b f e . .\n        . . . f f 1 d 1 d 1 d f f . . .\n        . . . . . f f b b f f . . . . .\n    `)\n    controller.moveSprite(mySprite)\n    scene.cameraFollowSprite(mySprite)\n\n    let flag = false;\n    controller.A.onEvent(ControllerButtonEvent.Pressed, () => {\n        const res = scene.aStar(tiles.getTileLocation(0, 11), tiles.getTileLocation(0, 3), sprites.castle.tilePath5);\n        const enemy = sprites.create(img`\n            . . . . . . . . . . . . . . . .\n            . . . . . . 6 6 6 6 . . . . . .\n            . . . . 6 6 6 5 5 6 6 6 . . . .\n            . . . 7 7 7 7 6 6 6 6 6 6 . . .\n            . . 6 7 7 7 7 8 8 8 1 1 6 6 . .\n            . . 7 7 7 7 7 8 8 8 1 1 5 6 . .\n            . 6 7 7 7 7 8 8 8 8 8 5 5 6 6 .\n            . 6 7 7 7 8 8 8 6 6 6 6 5 6 6 .\n            . 6 6 7 7 8 8 6 6 6 6 6 6 6 6 .\n            . 6 8 7 7 8 8 6 6 6 6 6 6 6 6 .\n            . . 6 8 7 7 8 6 6 6 6 6 8 6 . .\n            . . 6 8 8 7 8 8 6 6 6 8 6 6 . .\n            . . . 6 8 8 8 8 8 8 8 8 6 . . .\n            . . . . 6 6 8 8 8 8 6 6 . . . .\n            . . . . . . 6 6 6 6 . . . . . .\n            . . . . . . . . . . . . . . . .\n        `, SpriteKind.Enemy)\n        enemy.setPosition(mySprite.x, mySprite.y)\n        scene.followPath(enemy, res)\n    });\n    mySprite.setFlag(SpriteFlag.BounceOnWall, false)\n    scene.onPathCompletion(SpriteKind.Enemy, function (sprite: Sprite, location: tiles.Location) {\n        sprite.destroy(effects.ashes);\n    });\n\n    controller.B.onEvent(ControllerButtonEvent.Pressed, () => {\n        const pfs = sprites.allOfKind(SpriteKind.Enemy);\n        pfs.forEach(s => {\n            scene.followPath(s, null);\n            s.vx = 0;\n            s.vy = 0;\n        });\n    });\n\n    const dbg = false;\n    game.onUpdate(() => {\n        if (dbg) {\n            sprites.allOfKind(SpriteKind.Enemy)\n                .forEach(s => s.say(Math.round(scene.spritePercentPathCompleted(s)).toString()));\n        }\n    });\n}\n"}}